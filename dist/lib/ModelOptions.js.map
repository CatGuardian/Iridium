{"version":3,"sources":["lib/ModelOptions.ts"],"names":[],"mappings":"AAqIC","file":"lib/ModelOptions.js","sourcesContent":["/// <reference path=\"../_references.d.ts\" />\r\nimport MongoDB = require('mongodb');\r\nimport * as Index from './Index';\r\nimport {Hooks} from './Hooks';\r\nimport {CacheDirector} from './CacheDirector';\r\nimport * as General from './General';\r\n\r\n/**\r\n * Options which can be used to control the way in which a query is executed\r\n * against the MongoDB database.\r\n */\r\nexport interface QueryOptions {\r\n    cache?: boolean;\r\n    fields?: { [name: string]: number };\r\n    limit?: number;\r\n    skip?: number;\r\n    sort?: Index.IndexSpecification;\r\n}\r\n\r\n/**\r\n * Options which can be used to control the way in which a document is created\r\n * on the MongoDB server.\r\n */\r\nexport interface CreateOptions {\r\n    /**\r\n     * The write concern, can either be a number from 0 to the number of nodes within\r\n     * the cluster, or 'majority' if you would like to wait for the majority of nodes\r\n     * within the cluster to confirm the write before returning.\r\n     * \r\n     * It is recommended that you set this to 'majority', however in all situations\r\n     * where you mind if data is lost, you should set it to at least 1.\r\n     */\r\n    w?: string | number;\r\n    \r\n    /**\r\n     * The timeout in milliseconds before the write will be aborted by the MongoDB server\r\n     * and an error response (if the write concern is non-zero) is returned to the client.\r\n     */\r\n    wtimeout?: number;\r\n    \r\n    /**\r\n     * Whether to wait for the write to be commited to the server's journal (flushed to disk)\r\n     * or not. By specifying 1 here, you imply w:1 - howver this can be combined with w:'majority'\r\n     * to give excellent write reliability within a cluster, even across failures.\r\n     */\r\n    j?: number;\r\n    \r\n    /**\r\n     * Whether or not to serialize JavaScript functions which are provided as values. For security\r\n     * reasons it is probably best to set this to false, however it may come in handy under certain\r\n     * circumstances.\r\n     */\r\n    serializeFunctions?: boolean;\r\n    \r\n    /**\r\n     * Whether to generate document ObjectIDs within the client library or on the server, it is recommended\r\n     * that you leave this to default (false) unless you are making thousands of inserts per second from\r\n     * a single node and experiencing _id collisions.\r\n     */\r\n    forceServerObjectId?: boolean;\r\n    \r\n    /**\r\n     * Whether to perform an upsert operation if the document already exists.\r\n     */\r\n    upsert?: boolean;\r\n    \r\n    /**\r\n     * Whether to store the resulting document in the Iridium document cache to boost later retrieval times.\r\n     */\r\n    cache?: boolean;\r\n}\r\n\r\nexport interface UpdateOptions {\r\n    /**\r\n     * The write concern, can either be a number from 0 to the number of nodes within\r\n     * the cluster, or 'majority' if you would like to wait for the majority of nodes\r\n     * within the cluster to confirm the write before returning.\r\n     * \r\n     * It is recommended that you set this to 'majority', however in all situations\r\n     * where you mind if data is lost, you should set it to at least 1.\r\n     */\r\n    w?: string | number;\r\n    \r\n    /**\r\n     * The timeout in milliseconds before the write will be aborted by the MongoDB server\r\n     * and an error response (if the write concern is non-zero) is returned to the client.\r\n     */\r\n    wtimeout?: number;\r\n    \r\n    /**\r\n     * Whether to wait for the write to be commited to the server's journal (flushed to disk)\r\n     * or not. By specifying 1 here, you imply w:1 - howver this can be combined with w:'majority'\r\n     * to give excellent write reliability within a cluster, even across failures.\r\n     */\r\n    j?: boolean;\r\n    \r\n    /**\r\n     * Whether to perform an upsert operation if the document already exists. This can be combined\r\n     * with $setOnInsert to automatically create documents which do not exist in the database prior\r\n     * to making changes - and can be very handy for high-throughput systems.\r\n     */\r\n    upsert?: boolean;\r\n}\r\n\r\nexport interface RemoveOptions {\r\n    /**\r\n     * The write concern, can either be a number from 0 to the number of nodes within\r\n     * the cluster, or 'majority' if you would like to wait for the majority of nodes\r\n     * within the cluster to confirm the write before returning.\r\n     * \r\n     * It is recommended that you set this to 'majority', however in all situations\r\n     * where you mind if data is lost, you should set it to at least 1.\r\n     */\r\n    w?: string | number;\r\n    \r\n    /**\r\n     * The timeout in milliseconds before the write will be aborted by the MongoDB server\r\n     * and an error response (if the write concern is non-zero) is returned to the client.\r\n     */\r\n    wtimeout?: number;\r\n    \r\n    /**\r\n     * Whether to wait for the write to be commited to the server's journal (flushed to disk)\r\n     * or not. By specifying 1 here, you imply w:1 - howver this can be combined with w:'majority'\r\n     * to give excellent write reliability within a cluster, even across failures.\r\n     */\r\n    j?: number;\r\n    \r\n    /**\r\n     * Whether to only remove the first document in the collection or not, by default this is false\r\n     * and any document matching the conditions will be removed.\r\n     */\r\n    single?: boolean;\r\n}"],"sourceRoot":"/source/"}