{"version":3,"sources":["lib/Decorators.ts"],"names":[],"mappings":"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","file":"lib/Decorators.js","sourcesContent":["import * as MongoDB from \"mongodb\";\r\nimport * as _ from \"lodash\";\r\nimport Skmatc = require(\"skmatc\");\r\nimport {Instance} from \"./Instance\";\r\nimport {Model} from \"./Model\";\r\nimport {Index, IndexSpecification} from \"./Index\";\r\nimport {Schema} from \"./Schema\";\r\nimport {InstanceImplementation} from \"./InstanceInterface\";\r\nimport {Transforms, DefaultTransforms} from \"./Transforms\";\r\n\r\n/**\r\n * Specifies the name of the collection to which this instance's documents should be sent.\r\n * @param name The name of the MongoDB collection to store the documents in.\r\n *\r\n * This decorator replaces the use of the static collection property on instance implementation\r\n * classes. If your transpiler does not support decorators then you are free to make use of the\r\n * property instead.\r\n */\r\nexport function Collection(name: string) {\r\n\treturn function(target: InstanceImplementation<any, any>) {\r\n\t\ttarget.collection = name;\r\n\t};\r\n}\r\n\r\n/**\r\n * Specifies a MongoDB collection level index to be managed by Iridium for this instance type.\r\n * More than one instance of this decorator may be used if you wish to specify multiple indexes.\r\n * @param spec The formal index specification which defines the properties and ordering used in the index.\r\n * @param options The options dictating the way in which the index behaves.\r\n *\r\n * This decorator replaces the use of the static indexes property on instance implementation\r\n * classes. If your transpiler does not support decorators then you are free to make use of the\r\n * property instead.\r\n */\r\nexport function Index(spec: IndexSpecification, options?: MongoDB.IndexOptions) {\r\n\treturn function(target: InstanceImplementation<any,any>) {\r\n\t\ttarget.indexes = (target.indexes || []).concat(<Index>{ spec: spec, options: options || {} });\r\n\t}\r\n}\r\n\r\n/**\r\n * Specifies a custom validator to be made available for this collection's schema.\r\n * More than one instance of this decorator may be used if you wish to specify multiple validators.\r\n * @param forType The value in the schema which will be delegated to this function for validation.\r\n * @param validate A function which calls this.assert(condition) to determine whether a schema node is valid or not.\r\n *\r\n * This decorator replaces the use of the static validators property on instance implementation\r\n * classes. If your transpiler does not support decorators then you are free to make use of the\r\n * property instead.\r\n */\r\nexport function Validate(forType: any, validate: (schema: any, data: any, path: string) => Skmatc.Result) {\r\n\treturn function(target: InstanceImplementation<any,any>) {\r\n\t\ttarget.validators = (target.validators || []).concat(Skmatc.create(schema => schema === forType, validate));\r\n\t}\r\n}\r\n\r\n/**\r\n * Specifies the schema type for the property this decorator is applied to. This can be used to replace the\r\n * static schema property on your instance. Multiple instances of this decorator can be applied, but no more\r\n * than one per property.\r\n *\r\n * @param asType The schema validation type to make use of for this property\r\n * @param required Whether this property is required to have a value or not, defaults to true.\r\n */\r\nexport function Property(asType: any, required?: boolean): (target: Instance<any, any>, name: string) => void;\r\n/**\r\n * Specifies the schema type for a property with the given name on the class this decorator is applied to. This\r\n * can either compliment or replace the static schema property on your instance class.\r\n *\r\n * @param name The name of the property that is being targetted\r\n * @param asType The schema validation type to make use of for this property\r\n * @param required Whether this property is required to have a value or not, defaults to true.\r\n */\r\nexport function Property(name: string, asType: any, required?: boolean): (target: InstanceImplementation<any, any>) => void;\r\nexport function Property(...args: any[]): (target: Instance<any, any> | InstanceImplementation<any, any>, name?: string) => void {\r\n\tlet name = null,\r\n\t\tasType = false,\r\n\t\trequired = true;\r\n\r\n\tif (args.length > 1 && typeof args[args.length - 1] === \"boolean\")\r\n\t\trequired = args.pop();\r\n\r\n\treturn function(target: InstanceImplementation<any, any>, property?: string) {\r\n\t\tlet staticTarget: InstanceImplementation<any, any> = target;\r\n\t\tif (!property) name = args.shift();\r\n\t\telse {\r\n\t\t\tname = property;\r\n\t\t\tstaticTarget = <InstanceImplementation<any, any>>target.constructor;\r\n\t\t}\r\n\t\tasType = args.pop() || false;\r\n\r\n\t\tstaticTarget.schema = _.clone(staticTarget.schema || { _id: false });\r\n\t\tif(!required && typeof asType !== \"boolean\") staticTarget.schema[name] = { $required: required, $type: asType };\r\n\t\telse staticTarget.schema[name] = asType;\r\n\t}\r\n}\r\n\r\n/**\r\n * Specifies a custom transform to be applied to the property this decorator is applied to.\r\n *\r\n * @param fromDB The function used to convert values from the database for the application.\r\n * @param toDB The function used to convert values from the application to the form used in the database.\r\n *\r\n * This decorator can either compliment or replace the static transforms property on your instance\r\n * class, however only one transform can be applied to any property at a time.\r\n * If your transpiler does not support decorators then you are free to make use of the\r\n * property instead.\r\n * \r\n * If this decorator is applied to the instance class itself, as opposed to a property, then\r\n * it will be treated as a $document transformer - and will receive the full document as opposed\r\n * to individual property values. Similarly, it is expected to return a full document when either\r\n * fromDB or toDB is called.\r\n */\r\nexport function Transform(fromDB: (value: any, property: string, model: Model<any,any>) => any, toDB: (value: any, property: string, model: Model<any,any>) => any) {\r\n\treturn function(target: Instance<any, any>, property: string = \"$document\") {\r\n\t\tlet staticTarget: InstanceImplementation<any, any> = <InstanceImplementation<any, any>>(target.constructor || target);\r\n\r\n\t\tstaticTarget.transforms = _.clone(staticTarget.transforms || <Transforms>{})\r\n\t\tstaticTarget.transforms[property] = {\r\n\t\t\tfromDB: fromDB,\r\n\t\t\ttoDB: toDB\r\n\t\t};\r\n\t};\r\n}\r\n\r\n\r\n/**\r\n * Specifies that this property should be treated as an ObjectID, with the requisite validator and transforms.\r\n *\r\n * This decorator applies an ObjectID validator to the property, which ensures that values sent to the database\r\n * are instances of the MongoDB ObjectID type, as well as applying a transform operation which converts ObjectIDs\r\n * to strings for your application, and then converts strings back to ObjectIDs for the database.\r\n */\r\nexport function ObjectID(target: Instance<any, any>, name: string) {\r\n\tProperty(MongoDB.ObjectID)(target, name);\r\n\tTransform(\r\n\t\tDefaultTransforms.ObjectID.fromDB,\r\n\t\tDefaultTransforms.ObjectID.toDB\r\n\t)(target, name);\r\n}\r\n\r\n/**\r\n * Specifies that this property should be stored using the MongoDB binary type and represented as a Buffer.\r\n * \r\n * This decorator applies a Buffer validator to the property, which ensures that values you send to the database\r\n * are well formatted Buffer objects represented using the BSON Binary datatype. In addition to this, it will\r\n * apply a transform which ensures you only work with Buffer objects and that data is always stored in Binary\r\n * format.\r\n */\r\nexport function Binary(target: Instance<any, any>, name: string) {\r\n\tProperty(Buffer)(target, name);\r\n\tTransform(\r\n\t\tDefaultTransforms.Binary.fromDB,\r\n\t\tDefaultTransforms.Binary.toDB\r\n\t)(target, name);\r\n}"],"sourceRoot":"/source/"}